# Implementation Plan: Task 4.1 - Comprehensive Error Handling (FR-10)

**Created by**: implementation-planner
**Executed by**: implementation-executor
**Date**: 2025-01-19
**Version**: v1.0
**Status**: ‚úÖ COMPLETE - Production Ready
**Completion Date**: 2025-01-19
**Code Review**: APPROVED (8.5/10)

---

## 1. Overview

### Feature/Task Description

Implement comprehensive error handling infrastructure that provides clear, actionable error messages with appropriate exit codes for different failure scenarios. This task establishes a robust error classification system that distinguishes between fatal and recoverable errors, provides helpful guidance to users, and maintains excellent CLI user experience during failures.

**Goal**: Create a production-ready error handling system that satisfies FR-10 and PRD Section 13 requirements, providing users with clear, actionable feedback for all error scenarios while maintaining system stability and recoverability.

**Scope**:
- **Included**:
  - Structured exit code system (ExitCodes enum with 8 categories)
  - Enhanced error class with context and error codes (CliError)
  - Error formatting with actionable guidance (ErrorHandler)
  - Integration with existing parser and CLI
  - Fatal vs recoverable error classification
  - Verbose mode support for debugging
  - File-level error recovery (graceful degradation)
  - Memory constraint handling with suggestions
  - Uncaught exception handling

- **Excluded**:
  - Error reporting/telemetry to external services
  - Interactive error recovery workflows
  - Error history or logging to files
  - Custom error messages per user locale

**Priority**: High (Milestone 4 - Quality & Reliability)

### Context & Background

- **Requirements**: @docs/prd/mvp-requirements.md#13-error-handling
- **Related Documentation**:
  - @docs/prd/mvp-requirements.md#6-functional-requirements (FR-10, FR-14)
  - @docs/rules/tdd-development-workflow.md
  - @docs/rules/ai-development-guide.md
- **Dependencies**:
  - Task 1.1 (Project Loading) - provides initial error scenarios
  - Task 1.2 (Class Collection) - file parsing error recovery
  - Task 1.3 (Token Resolution) - type resolution errors
  - Existing parser.ts implementation
  - Existing cli/index.ts implementation

---

## 2. Technical Approach

### Architecture Decisions

**Design Pattern**:
- **Custom Error Class Pattern**: Extend JavaScript Error with CliError class for structured error information
- **Static ErrorHandler Pattern**: Centralized error handling utilities without maintaining state
- **Early Exit Pattern**: Fail fast for fatal errors, continue for recoverable errors

**Technology Stack**:
- TypeScript 5.x for type safety
- Node.js process management for exit codes
- Bun test runner for comprehensive error scenario testing
- ts-morph integration for parsing error context

**Integration Points**:
1. **Parser Integration** (`src/core/parser.ts`):
   - Replace ad-hoc error throwing with CliError instances
   - Add structured error handling in loadProject(), parseClasses(), parseSourceFile()
   - Implement file-level error recovery with graceful degradation

2. **CLI Integration** (`src/cli/index.ts`):
   - Replace generic try-catch with ErrorHandler.handleError()
   - Add global process event handlers for uncaught exceptions
   - Enhanced verbose mode error reporting

3. **Type System Integration** (`src/types/index.ts`):
   - Extend ParserError interface to align with CliError
   - Add ErrorCode type union
   - Export ExitCodes enum for external use

### File Structure
```
src/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ error-handler.ts      # NEW: Main error handling infrastructure
‚îÇ   ‚îú‚îÄ‚îÄ parser.ts              # MODIFIED: Enhanced error handling
‚îÇ   ‚îî‚îÄ‚îÄ graph-builder.ts       # Future: Error handling integration
‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îî‚îÄ‚îÄ index.ts               # MODIFIED: Structured CLI error handling
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ index.ts               # MODIFIED: Extended error interfaces

tests/
‚îú‚îÄ‚îÄ error-handling.test.ts     # NEW: Comprehensive error handling tests
‚îú‚îÄ‚îÄ parser.test.ts             # MODIFIED: Enhanced error scenario tests
‚îî‚îÄ‚îÄ cli.test.ts                # Future: CLI error handling tests
```

### Data Flow

1. **Error Detection** ‚Üí Error thrown as CliError with code, message, context
2. **Error Classification** ‚Üí ErrorHandler.classifyExitCode() maps to exit code
3. **Error Formatting** ‚Üí ErrorHandler.formatError() creates user-friendly output
4. **Error Recovery** ‚Üí Fatal errors exit, recoverable errors warn and continue
5. **Error Output** ‚Üí Formatted to stderr with guidance for resolution

---

## 3. Implementation Tasks

### Phase 1: Core Error Infrastructure (TDD Foundation)
**Priority**: High
**Estimated Duration**: 2-3 hours

- [ ] **Task 1.1**: Create ExitCodes enum and ErrorCode type
  - **TDD Approach**:
    - Write test to verify all exit codes are defined (SUCCESS=0, GENERAL_ERROR=1, etc.)
    - Write test to verify ErrorCode type includes all error scenarios
  - **Implementation**:
    - Define ExitCodes enum with 8 exit codes from PRD Section 13
    - Define ErrorCode type union with 14 error scenarios
  - **Acceptance Criteria**:
    - ExitCodes enum exports SUCCESS=0, TSCONFIG_ERROR=3, PARSING_ERROR=4, etc.
    - ErrorCode type covers all error scenarios in PRD Section 13
    - TypeScript compilation passes with strict type checking

- [ ] **Task 1.2**: Implement CliError class
  - **TDD Approach**:
    - Write test for CliError constructor with all properties
    - Write test for isFatal() classification
    - Write test for isRecoverable() inverse of isFatal()
    - Write test for instanceof Error compatibility
  - **Implementation**:
    - Create CliError class extending Error
    - Add code, filePath, context properties
    - Implement isFatal() with fatal error code list
    - Implement isRecoverable() as !isFatal()
  - **Acceptance Criteria**:
    - CliError extends Error properly
    - All error codes classify correctly (fatal vs recoverable)
    - Error context preserved through throw/catch cycles
    - Stack traces maintained properly

- [ ] **Task 1.3**: Implement ErrorHandler.classifyExitCode()
  - **TDD Approach**:
    - Write tests for each error code mapping to exit code
    - Write test for null error returning SUCCESS
    - Write test for unknown errors returning GENERAL_ERROR
  - **Implementation**:
    - Create static method with switch/case for error code mapping
    - Map TSCONFIG errors ‚Üí ExitCodes.TSCONFIG_ERROR
    - Map parsing errors ‚Üí ExitCodes.PARSING_ERROR
    - Default to GENERAL_ERROR for unknown codes
  - **Acceptance Criteria**:
    - All 14 error codes map to correct exit codes
    - Null/undefined errors return SUCCESS
    - Unknown error codes default to GENERAL_ERROR
    - All PRD Section 13 scenarios covered

### Phase 2: Error Formatting & Guidance (User Experience)
**Priority**: High
**Estimated Duration**: 2-3 hours

- [ ] **Task 2.1**: Implement ErrorHandler.formatError()
  - **TDD Approach**:
    - Write test for basic error formatting (header, message, code)
    - Write test for file path inclusion in output
    - Write test for context object rendering
    - Write test for verbose mode stack trace inclusion
    - Write test for emoji usage in headers (fatal vs warning)
  - **Implementation**:
    - Create formatError(error, verbose) method
    - Build multi-line error output with sections
    - Include emoji indicators for severity (‚ùå Fatal, ‚ö†Ô∏è Warning)
    - Add context rendering as JSON
    - Conditionally include stack traces in verbose mode
  - **Acceptance Criteria**:
    - Error output is clear and well-structured
    - Fatal errors show ‚ùå Fatal Error header
    - Warnings show ‚ö†Ô∏è Warning header
    - File paths included when available
    - Stack traces only in verbose mode
    - All output is human-readable

- [ ] **Task 2.2**: Implement ErrorHandler.getRecoveryGuidance()
  - **TDD Approach**:
    - Write test for each error code's guidance message
    - Write test for file path interpolation in guidance
    - Write test for chunking suggestions for memory errors
    - Write test for type annotation suggestions
  - **Implementation**:
    - Create switch/case for all 14 error codes
    - Provide 3-4 specific, actionable suggestions per error
    - Include file paths in guidance when available
    - Format as bulleted list with "üí° Suggestions:" header
  - **Acceptance Criteria**:
    - All 14 error codes have unique guidance
    - Guidance is specific and actionable
    - Memory errors suggest chunking strategies
    - Type errors suggest annotation improvements
    - Import errors suggest dependency checking
    - All guidance follows consistent format

- [ ] **Task 2.3**: Implement ErrorHandler.handleError() and helper methods
  - **TDD Approach**:
    - Write test for process.exit() with correct exit code
    - Write test for stderr output formatting
    - Write test for ErrorHandler.warn() output
    - Write test for ErrorHandler.createError() factory
  - **Implementation**:
    - Implement handleError() to format and exit
    - Implement warn() for non-fatal warnings
    - Implement createError() factory method
    - Ensure all methods are static (no state)
  - **Acceptance Criteria**:
    - handleError() exits with correct code
    - Errors output to stderr, not stdout
    - warn() outputs to stderr without exiting
    - createError() simplifies error instantiation
    - All methods are static and stateless

### Phase 3: Parser Integration (Error Recovery)
**Priority**: High
**Estimated Duration**: 2-3 hours

- [ ] **Task 3.1**: Enhance parser.loadProject() error handling
  - **TDD Approach**:
    - Write test for TSCONFIG_NOT_FOUND error
    - Write test for TSCONFIG_INVALID (JSON syntax) error
    - Write test for PROJECT_LOAD_FAILED error
    - Write test for COMPILATION_ERROR with diagnostics
  - **Implementation**:
    - Replace current error throwing with ErrorHandler.createError()
    - Add file existence validation before loading
    - Add JSON syntax validation with try-catch
    - Add TypeScript diagnostics checking
    - Preserve error stack traces
  - **Acceptance Criteria**:
    - Missing tsconfig throws TSCONFIG_NOT_FOUND
    - Invalid JSON throws TSCONFIG_INVALID
    - Project load failures throw PROJECT_LOAD_FAILED
    - All errors include file path
    - Error context includes relevant details

- [ ] **Task 3.2**: Implement file-level error recovery in parser.parseClasses()
  - **TDD Approach**:
    - Write test for continuing after file parse error
    - Write test for skipped file count tracking
    - Write test for verbose mode file processing logs
    - Write test for warning output for skipped files
  - **Implementation**:
    - Wrap parseSourceFile() in try-catch per file
    - Track processedFiles and skippedFiles counters
    - Use ErrorHandler.warn() for non-fatal file errors
    - Continue processing remaining files
    - Log statistics in verbose mode
  - **Acceptance Criteria**:
    - Individual file failures don't stop processing
    - Skipped files logged with warnings
    - Successfully processed files counted
    - Verbose mode shows detailed progress
    - Zero decorated classes shows warning, not error

- [ ] **Task 3.3**: Update parser error throwing to use CliError
  - **TDD Approach**:
    - Write test for anonymous class warnings
    - Write test for type resolution error warnings
    - Write test for file parse error handling
  - **Implementation**:
    - Replace all throw new Error() with ErrorHandler.createError()
    - Update anonymous class handling to use warn()
    - Update type resolution failures to use structured warnings
    - Maintain backward compatibility with existing error handling
  - **Acceptance Criteria**:
    - All parser errors use CliError
    - Error codes correctly classify errors
    - File paths included in all relevant errors
    - Context objects provide useful debugging info
    - No regression in existing error handling

### Phase 4: CLI Integration & Global Handlers (System Resilience)
**Priority**: High
**Estimated Duration**: 1-2 hours

- [ ] **Task 4.1**: Enhance CLI main action error handling
  - **TDD Approach**:
    - Write test for CliError handling in CLI
    - Write test for generic Error conversion to CliError
    - Write test for unknown error handling
    - Write test for verbose mode in error handling
  - **Implementation**:
    - Replace generic catch block with instanceof checks
    - Use ErrorHandler.handleError() for CliError
    - Convert generic Error to INTERNAL_ERROR CliError
    - Handle unknown errors gracefully
    - Pass verbose flag to error handler
  - **Acceptance Criteria**:
    - All errors handled with appropriate exit codes
    - CliError instances handled natively
    - Generic errors converted to INTERNAL_ERROR
    - Unknown errors don't crash with stack traces
    - Verbose mode provides detailed error info

- [ ] **Task 4.2**: Implement global process event handlers
  - **TDD Approach**:
    - Write test for unhandledRejection handler (if testable)
    - Write test for uncaughtException handler (if testable)
    - Verify handlers convert to INTERNAL_ERROR
  - **Implementation**:
    - Update existing process.on('unhandledRejection') handler
    - Add process.on('uncaughtException') handler
    - Both handlers use ErrorHandler.handleError()
    - Include error context and stack traces
  - **Acceptance Criteria**:
    - Unhandled rejections don't crash silently
    - Uncaught exceptions provide clear error output
    - Both handlers exit with GENERAL_ERROR code
    - Stack traces included for debugging
    - Error messages are user-friendly

- [ ] **Task 4.3**: Update types/index.ts with error interfaces
  - **TDD Approach**:
    - Write test for ParserError compatibility with CliError
    - Verify ErrorCode type exports correctly
  - **Implementation**:
    - Extend ParserError interface to align with CliError
    - Export ErrorCode type from error-handler
    - Deprecate old ParserError code values if needed
    - Ensure backward compatibility
  - **Acceptance Criteria**:
    - ParserError and CliError are compatible
    - ErrorCode type exported and usable
    - No breaking changes to existing code
    - TypeScript compilation succeeds

### Phase 5: Testing & Validation (Quality Assurance)
**Priority**: High
**Estimated Duration**: 2-3 hours

- [ ] **Task 5.1**: Write comprehensive error scenario tests
  - **TDD Approach**:
    - Write integration tests for all PRD Section 13 scenarios
    - Write test for each exit code path
    - Write tests for error message quality
    - Write tests for guidance actionability
  - **Implementation**:
    - Create tests/error-handling.test.ts with full coverage
    - Test all error code classifications
    - Test error message formatting variations
    - Test recovery guidance for each error type
    - Test fatal vs recoverable distinctions
  - **Acceptance Criteria**:
    - >95% code coverage for error-handler.ts
    - All PRD Section 13 scenarios tested
    - Exit code mapping 100% covered
    - Error formatting variations tested
    - Recovery guidance tested per error code

- [ ] **Task 5.2**: Write parser integration tests
  - **TDD Approach**:
    - Write test for parser error handling with invalid tsconfig
    - Write test for file-level error recovery
    - Write test for continued processing after errors
  - **Implementation**:
    - Update tests/parser.test.ts with error scenarios
    - Test TSCONFIG_NOT_FOUND path
    - Test TSCONFIG_INVALID path
    - Test PROJECT_LOAD_FAILED path
    - Test file-level error recovery
  - **Acceptance Criteria**:
    - Parser error handling tested end-to-end
    - Invalid configurations handled gracefully
    - File parsing errors don't crash parser
    - Error recovery maintains data integrity
    - Verbose mode tested for error logging

- [ ] **Task 5.3**: Write CLI integration tests (if feasible with current setup)
  - **TDD Approach**:
    - Write test for CLI error handling flow
    - Write test for exit code propagation
    - Verify verbose mode error output
  - **Implementation**:
    - Create CLI-level error tests if testing infrastructure supports
    - Mock error scenarios and verify handling
    - Test command-line error output
  - **Acceptance Criteria**:
    - CLI error handling flow tested
    - Exit codes verified at CLI level
    - Error output format validated
    - Verbose mode behavior confirmed

### Phase 6: Performance & Polish (Optimization)
**Priority**: Medium
**Estimated Duration**: 1-2 hours

- [ ] **Task 6.1**: Performance validation and optimization
  - **TDD Approach**:
    - Write performance test for error handling overhead
    - Verify <1% performance impact
  - **Implementation**:
    - Profile error handling code paths
    - Optimize string formatting if needed
    - Minimize object allocation in hot paths
    - Lazy-load stack trace capture
  - **Acceptance Criteria**:
    - Error handling adds <1% overhead to successful runs
    - No memory leaks in error handling
    - Stack trace capture only when needed
    - Error object allocation minimized

- [ ] **Task 6.2**: Documentation and final polish
  - **TDD Approach**:
    - Document all error codes in CLI help
    - Document error handling patterns for future development
  - **Implementation**:
    - Add error code documentation comments
    - Update CLI help text with error information
    - Add examples to inline documentation
  - **Acceptance Criteria**:
    - All error codes documented in code
    - CLI help includes error handling info
    - Inline examples provided
    - README updated if needed

---

## 4. Test-Driven Development Plan

### Test Strategy

**Approach**: Follow mandatory TDD workflow from @docs/rules/tdd-development-workflow.md

**Test Categories**:
- **Unit Tests**:
  - CliError class instantiation and methods
  - ErrorHandler static methods (classifyExitCode, formatError, getRecoveryGuidance)
  - Exit code mapping for all error codes
  - Error message formatting variations

- **Integration Tests**:
  - Parser error handling with real tsconfig files
  - File-level error recovery in parseClasses()
  - CLI error handling flow from error to exit
  - End-to-end error scenarios from PRD Section 13

- **Edge Case Tests**:
  - Null/undefined error handling
  - Unknown error codes
  - Missing file paths in errors
  - Empty context objects
  - Malformed error instances

### Test Implementation Order

1. **Red Phase - Write Failing Tests**:
   - Start with ExitCodes enum and ErrorCode type tests
   - Write CliError class instantiation tests
   - Write ErrorHandler.classifyExitCode() tests for each error code
   - Write ErrorHandler.formatError() tests for various formats
   - Write getRecoveryGuidance() tests for each error code
   - Write parser integration tests for error scenarios
   - Write CLI integration tests for error handling

2. **Green Phase - Minimal Implementation**:
   - Implement ExitCodes and ErrorCode to pass type tests
   - Implement CliError with minimal functionality
   - Implement classifyExitCode() with switch/case
   - Implement formatError() with basic formatting
   - Implement getRecoveryGuidance() with switch/case
   - Update parser to throw CliError instances
   - Update CLI to use ErrorHandler.handleError()

3. **Refactor Phase - Optimize and Polish**:
   - Optimize string formatting for performance
   - Extract common error message patterns
   - Improve error message clarity based on test feedback
   - Add comprehensive inline documentation
   - Optimize for minimal memory allocation

### Test Files Structure

```
tests/
‚îú‚îÄ‚îÄ error-handling.test.ts      # NEW: Comprehensive error handling tests
‚îÇ   ‚îú‚îÄ‚îÄ ExitCodes enum tests
‚îÇ   ‚îú‚îÄ‚îÄ CliError class tests
‚îÇ   ‚îú‚îÄ‚îÄ ErrorHandler.classifyExitCode() tests
‚îÇ   ‚îú‚îÄ‚îÄ ErrorHandler.formatError() tests
‚îÇ   ‚îú‚îÄ‚îÄ ErrorHandler.getRecoveryGuidance() tests
‚îÇ   ‚îî‚îÄ‚îÄ Integration tests
‚îú‚îÄ‚îÄ parser.test.ts              # MODIFIED: Enhanced error scenario tests
‚îÇ   ‚îú‚îÄ‚îÄ loadProject() error tests
‚îÇ   ‚îú‚îÄ‚îÄ parseClasses() error recovery tests
‚îÇ   ‚îî‚îÄ‚îÄ File-level error handling tests
‚îî‚îÄ‚îÄ cli.test.ts                 # Future: CLI error handling tests
    ‚îî‚îÄ‚îÄ Command-line error flow tests
```

### Test Coverage Targets

- **error-handler.ts**: >95% line, branch, function coverage
- **Parser error handling paths**: >90% coverage
- **CLI error handling**: >85% coverage
- **Overall project**: Maintain >70% as per NFR-04

---

## 5. Technical Specifications

### Interfaces & Types

```typescript
/**
 * Exit codes for ng-di-graph CLI
 * Implements PRD Section 13 error handling requirements
 */
export enum ExitCodes {
  SUCCESS = 0,              // Successful execution
  GENERAL_ERROR = 1,        // Generic error (uncaught exception)
  INVALID_ARGUMENTS = 2,    // Invalid CLI arguments
  TSCONFIG_ERROR = 3,       // tsconfig.json not found or invalid
  PARSING_ERROR = 4,        // File parsing failure
  TYPE_RESOLUTION_ERROR = 5,// Type resolution failure
  MEMORY_ERROR = 6,         // Memory limit exceeded
  FILE_NOT_FOUND = 7,       // Required file not found
  PERMISSION_ERROR = 8      // Insufficient permissions
}

/**
 * Error codes for structured error handling
 * Each code maps to a specific error scenario
 */
export type ErrorCode =
  | 'TSCONFIG_NOT_FOUND'      // tsconfig.json file not found
  | 'TSCONFIG_INVALID'        // Invalid JSON or config
  | 'PROJECT_LOAD_FAILED'     // ts-morph project loading failed
  | 'COMPILATION_ERROR'       // TypeScript compilation errors
  | 'FILE_PARSE_ERROR'        // Individual file parsing failed
  | 'TYPE_RESOLUTION_ERROR'   // Cannot resolve dependency type
  | 'MEMORY_LIMIT_EXCEEDED'   // Memory constraints exceeded
  | 'DEPENDENCY_NOT_FOUND'    // Dependency cannot be resolved
  | 'ANONYMOUS_CLASS_SKIPPED' // Anonymous class encountered
  | 'INTERNAL_ERROR'          // Unexpected internal error
  | 'INVALID_ARGUMENTS'       // Invalid CLI arguments provided
  | 'FILE_NOT_FOUND'          // Required file not found
  | 'PERMISSION_DENIED'       // Insufficient file permissions
  | 'OUTPUT_WRITE_ERROR';     // Cannot write output file

/**
 * Custom error class for ng-di-graph CLI
 * Provides structured error information with context
 */
export class CliError extends Error {
  public readonly name = 'CliError';

  constructor(
    message: string,
    public readonly code: ErrorCode,
    public readonly filePath?: string,
    public readonly context?: Record<string, unknown>
  ) {
    super(message);
    Object.setPrototypeOf(this, CliError.prototype);
  }

  /**
   * Check if error is fatal (should exit immediately)
   */
  isFatal(): boolean;

  /**
   * Check if error is recoverable (can continue processing)
   */
  isRecoverable(): boolean;
}
```

### API Design

```typescript
/**
 * ErrorHandler - Static utility class for error handling
 * Provides centralized error formatting and exit code management
 */
export class ErrorHandler {
  /**
   * Map error code to exit code
   * @param error CliError instance or null
   * @returns Exit code for process.exit()
   */
  static classifyExitCode(error: CliError | null): ExitCodes;

  /**
   * Format error for user-friendly display
   * @param error CliError to format
   * @param verbose Include stack traces and detailed info
   * @returns Formatted error message string
   */
  static formatError(error: CliError, verbose: boolean): string;

  /**
   * Get actionable recovery guidance for error
   * @param error CliError to provide guidance for
   * @returns Multi-line guidance string
   */
  static getRecoveryGuidance(error: CliError): string;

  /**
   * Handle error and exit process (never returns)
   * @param error CliError to handle
   * @param verbose Include verbose error information
   */
  static handleError(error: CliError, verbose: boolean): never;

  /**
   * Factory method to create CliError
   * @param message Error message
   * @param code Error code
   * @param filePath Optional file path
   * @param context Optional context object
   * @returns CliError instance
   */
  static createError(
    message: string,
    code: ErrorCode,
    filePath?: string,
    context?: Record<string, unknown>
  ): CliError;

  /**
   * Output warning without exiting
   * @param message Warning message
   * @param filePath Optional file path
   */
  static warn(message: string, filePath?: string): void;
}
```

### Configuration

**No configuration required** - Error handling is hard-coded for consistency.

**Customization Points**:
- Exit codes (ExitCodes enum)
- Error messages (ErrorHandler.getRecoveryGuidance())
- Formatting style (ErrorHandler.formatError())

**Environment Variables**: None

---

## 6. Error Handling & Edge Cases

### Error Scenarios

From PRD Section 13, all scenarios must be handled:

| Scenario | Error Code | Exit Code | Behavior |
|----------|------------|-----------|----------|
| Missing/invalid tsconfig | TSCONFIG_NOT_FOUND / TSCONFIG_INVALID | 3 | Fatal - Abort with guidance |
| No decorated classes found | N/A (warning) | 0 | Warning only, exit success |
| Anonymous class | ANONYMOUS_CLASS_SKIPPED | 0 | Skip and warn, continue |
| Type resolution failed | TYPE_RESOLUTION_ERROR | 0 | Skip dependency, warn, continue |
| File parsing failure | FILE_PARSE_ERROR | 0 | Skip file, warn, continue |
| Circular dependency | N/A (reported in output) | 0 | Report in output, continue |
| Memory constraints | MEMORY_LIMIT_EXCEEDED | 6 | Fatal with chunking suggestions |
| Uncaught exception | INTERNAL_ERROR | 1 | Fatal with stack trace |

### Edge Cases

- **Edge Case 1**: Null or undefined error passed to classifyExitCode()
  - **Handling**: Return ExitCodes.SUCCESS (assume no error)

- **Edge Case 2**: CliError without filePath or context
  - **Handling**: Gracefully skip missing sections in formatError()

- **Edge Case 3**: Unknown ErrorCode not in switch/case
  - **Handling**: Default to ExitCodes.GENERAL_ERROR and generic guidance

- **Edge Case 4**: Error thrown during error handling
  - **Handling**: Use try-catch in handleError() with minimal fallback output

- **Edge Case 5**: Very long error messages or file paths
  - **Handling**: No truncation - preserve full information for debugging

### Validation Requirements

- **Input Validation**:
  - Validate error is instanceof CliError before handling
  - Validate ErrorCode is in known set
  - Validate exit code is 0-255 range

- **Output Validation**:
  - Ensure error output goes to stderr, not stdout
  - Ensure formatted error is non-empty string
  - Ensure guidance is actionable and specific

---

## 7. Performance Considerations

### Performance Requirements

- **Target Metrics**:
  - Error handling overhead <1% of total execution time on successful runs
  - Error formatting <10ms for typical errors
  - Memory allocation <1KB per error instance

- **Bottlenecks**:
  - String concatenation in formatError() - use array.join()
  - Stack trace capture - only in verbose mode
  - Error context serialization - lazy evaluation

- **Optimization Strategy**:
  - Minimize string allocations in hot paths
  - Lazy-load stack traces and context formatting
  - Cache common error message patterns
  - Avoid regex in error handling code

### Memory Management

- **Memory Usage**:
  - CliError instances: ~500 bytes each
  - Error formatting buffers: ~2KB temporary
  - No persistent error state maintained

- **Large Dataset Handling**:
  - Error handling should not scale with project size
  - File-level error recovery prevents memory accumulation
  - No error history or aggregation maintained

---

## 8. Progress Tracking

### Milestones

- [ ] **Milestone 1**: Core Infrastructure Complete - Target: 2-3 hours
  - [ ] ExitCodes enum and ErrorCode type implemented
  - [ ] CliError class fully implemented with tests
  - [ ] ErrorHandler.classifyExitCode() implemented with tests
  - [ ] All unit tests passing for core infrastructure
  - [ ] Test coverage >95% for error-handler.ts

- [ ] **Milestone 2**: Formatting & Guidance Complete - Target: +2-3 hours
  - [ ] ErrorHandler.formatError() implemented with tests
  - [ ] ErrorHandler.getRecoveryGuidance() implemented for all 14 codes
  - [ ] Error message quality validated with manual testing
  - [ ] All formatting tests passing

- [ ] **Milestone 3**: Integration Complete - Target: +3-4 hours
  - [ ] Parser error handling fully integrated
  - [ ] CLI error handling fully integrated
  - [ ] File-level error recovery working
  - [ ] Global process handlers implemented
  - [ ] All integration tests passing

- [ ] **Milestone 4**: Testing & Validation Complete - Target: +2-3 hours
  - [ ] Comprehensive error scenario tests passing
  - [ ] All PRD Section 13 scenarios validated
  - [ ] Test coverage meets targets (>95%)
  - [ ] Manual testing confirms error UX quality

- [ ] **Milestone 5**: Performance & Documentation Complete - Target: +1-2 hours
  - [ ] Performance overhead validated <1%
  - [ ] Documentation complete and reviewed
  - [ ] CLI help updated with error information
  - [ ] All acceptance criteria met

### Progress Updates

**Last Updated**: 2025-01-19
**Current Status**: Planning complete, ready for execution
**Blockers**: None
**Next Steps**: Begin Phase 1 with TDD approach - write tests for ExitCodes and CliError

---

## 9. Definition of Done

### Completion Criteria

- [ ] All implementation tasks completed (Phases 1-6)
- [ ] All tests passing (unit, integration, edge cases)
- [ ] Code review completed by code-reviewer agent
- [ ] Performance overhead validated <1%
- [ ] Documentation updated (inline comments, CLI help)
- [ ] No critical bugs or regressions
- [ ] Test coverage >95% for error-handler.ts
- [ ] Test coverage >90% for error handling paths in parser
- [ ] All PRD Section 13 scenarios handled correctly

### Acceptance Testing

- [ ] **Functional Requirements**:
  - [ ] FR-10: Exit codes correct for all error scenarios
  - [ ] FR-14: File parsing failures don't stop processing
  - [ ] All PRD Section 13 scenarios tested and working

- [ ] **Non-Functional Requirements**:
  - [ ] NFR-04: Test coverage >70% overall (target >95% for error handling)
  - [ ] Performance: <1% overhead for error handling infrastructure
  - [ ] UX: Error messages are clear, actionable, and user-friendly

- [ ] **Edge Cases**:
  - [ ] Null/undefined error handling tested
  - [ ] Unknown error codes default correctly
  - [ ] Missing file paths handled gracefully
  - [ ] Error during error handling has fallback

### Code Quality Checks

- [ ] `npm run lint` passes (Biome validation)
- [ ] `npm run typecheck` passes (TypeScript strict mode)
- [ ] `npm run test` all tests pass
- [ ] `npm run test:coverage` shows >95% for error-handler.ts
- [ ] No ESLint warnings or errors
- [ ] No TypeScript strict errors
- [ ] Code follows project style guidelines

---

## 10. Risk Assessment

### High Risk Items

- **Risk 1**: Error handling complexity may introduce new bugs
  - **Mitigation**: Comprehensive test coverage >95%, TDD approach, thorough code review

- **Risk 2**: Performance overhead from error handling infrastructure
  - **Mitigation**: Profile early, optimize string operations, lazy-load expensive operations

- **Risk 3**: Breaking changes to existing error handling
  - **Mitigation**: Maintain backward compatibility, gradual migration, thorough integration testing

### Dependencies & Blockers

- **External Dependencies**:
  - Node.js process management (process.exit, process.on)
  - TypeScript compiler for type checking
  - Bun test runner for testing

- **Internal Dependencies**:
  - Existing parser.ts implementation (Task 1.1, 1.2, 1.3)
  - Existing cli/index.ts implementation
  - types/index.ts for interface definitions

### Contingency Plans

- **Plan A**: Full TDD implementation as specified
  - Comprehensive test coverage
  - Iterative development with continuous testing

- **Plan B**: If TDD proves too time-consuming
  - Implement core functionality first
  - Add tests incrementally
  - Focus on critical error paths first

- **Plan C**: If performance issues arise
  - Profile and identify bottlenecks
  - Optimize only hot paths
  - Consider alternative string formatting approaches

---

## 11. Notes & Decisions

### Implementation Notes

**For implementation-executor**:

1. **TDD is Mandatory**: Start every phase by writing tests first
   - Run `npm run test:watch` continuously during development
   - Red ‚Üí Green ‚Üí Refactor cycle for each feature
   - Don't skip ahead to implementation without tests

2. **Error Message Quality Matters**:
   - User-friendly language, not technical jargon
   - Specific, actionable guidance for each error
   - Include examples in guidance when helpful
   - Test error messages manually for clarity

3. **Performance Considerations**:
   - Use array.join() instead of string concatenation
   - Lazy-load stack traces (only capture in verbose mode)
   - Minimize object allocation in error handling
   - Profile if any operations take >10ms

4. **Integration Strategy**:
   - Update parser.ts incrementally, method by method
   - Test each parser update independently
   - Keep CLI changes minimal and focused
   - Maintain backward compatibility throughout

5. **Testing Strategy**:
   - Start with unit tests for CliError and ErrorHandler
   - Progress to integration tests with parser
   - End with end-to-end CLI tests if feasible
   - Aim for >95% coverage on error-handler.ts

### Decision Log

- **Decision 1**: Use static ErrorHandler class instead of instance-based
  - **Rationale**: No state needed, simpler API, easier to use globally

- **Decision 2**: Extend Error class for CliError instead of custom class
  - **Rationale**: Maintains instanceof Error checks, preserves stack traces, standard pattern

- **Decision 3**: Output errors to stderr, not stdout
  - **Rationale**: Standard CLI convention, allows piping stdout without error pollution

- **Decision 4**: Use emoji in error headers (‚ùå, ‚ö†Ô∏è, üí°)
  - **Rationale**: Improves visual scanning, common in modern CLI tools, optional in verbose mode

- **Decision 5**: Provide 3-4 suggestions per error in recovery guidance
  - **Rationale**: Balance between helpful and overwhelming, specific enough to be actionable

### Questions for Executor

- **Question 1**: Should we add error telemetry hooks for future external reporting?
  - **Guidance**: Out of scope for MVP, but add TODO comments for future enhancement

- **Question 2**: Should error messages be localizable?
  - **Guidance**: No, English only for MVP, but structure code to allow future i18n

- **Question 3**: Should we validate exit codes are in 0-255 range?
  - **Guidance**: Yes, add assertion in ExitCodes enum definition

---

## 12. Resources & References

### Documentation

- **Requirements**: @docs/prd/mvp-requirements.md#13-error-handling
- **Workflow**: @docs/rules/tdd-development-workflow.md
- **Development Guide**: @docs/rules/ai-development-guide.md
- **Existing Task Document**: docs/plans/tasks/task-4.1-error-handling.md

### External Resources

- **Node.js Process API**: https://nodejs.org/api/process.html#exit-codes
- **Error Handling Best Practices**: https://nodejs.org/en/docs/guides/error-handling/
- **TypeScript Error Handling**: https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing
- **CLI Error Messages**: https://clig.dev/#errors

### Code Examples

**Reference Implementations**:
- Existing parser.ts error handling (lines 116-213)
- Existing cli/index.ts error handling (lines 132-142)
- Existing types/index.ts ParserError interface (lines 63-66)

**Similar Patterns in Codebase**:
- AngularParser.loadProject() error handling structure
- Warning system in parser (console.warn usage)
- Verbose mode conditional logging patterns

---

## 13. Test Development Commands

**Run tests continuously during development**:
```bash
npm run test:watch
```

**Check test coverage**:
```bash
npm run test:coverage
```

**Validate code quality**:
```bash
npm run lint
npm run typecheck
npm run test
```

**Run specific test file**:
```bash
bun test tests/error-handling.test.ts
```

---

## Execution Readiness Checklist

- [x] Planning document complete and comprehensive
- [x] Technical approach validated against PRD requirements
- [x] TDD workflow clearly defined
- [x] Test structure planned with specific test cases
- [x] Implementation phases broken down into focused tasks
- [x] Acceptance criteria defined for each task
- [x] Integration points identified and documented
- [x] Performance targets specified
- [x] Risk mitigation strategies defined
- [x] Definition of Done provides clear completion criteria

**Status**: ‚úÖ Ready for execution by implementation-executor

---

**Plan Version**: 1.0
**Plan Status**: Complete
**Next Action**: Execute Phase 1 with TDD approach - begin with ExitCodes enum tests
